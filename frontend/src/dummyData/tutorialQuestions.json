[
  {
    "question": "Which ACID property ensures that a transaction either completes in its entirety or does not occur at all?",
    "options": ["Atomicity", "Consistency", "Isolation", "Durability"],
    "answer": "Atomicity",
    "type": "mcq"
  },
  {
    "question": "What does the Isolation property guarantee in the context of concurrent transaction execution?",
    "options": [
      "Transactions are aware of each other's modifications.",
      "Each transaction appears to execute sequentially.",
      "Transactions can interfere with each other to ensure speed.",
      "All transactions are merged into a single operation."
    ],
    "answer": "Each transaction appears to execute sequentially.",
    "type": "mcq"
  },
  {
    "question": "If a transaction is described as 'consistency preserving', what does it imply about the state of the database?",
    "options": [
      "The database may reach an inconsistent state temporarily.",
      "The database state is unchanged by the transaction.",
      "The transaction takes the database from one consistent state to another.",
      "The transaction does not affect the database durability."
    ],
    "answer": "The transaction takes the database from one consistent state to another.",
    "type": "mcq"
  },
  {
    "question": "Which concurrency control mechanism ensures that a transaction only reads data that has been committed, thus preventing cascading aborts?",
    "options": [
      "Locking",
      "Timestamp ordering",
      "Snapshot isolation",
      "Cascadeless schedules"
    ],
    "answer": "Cascadeless schedules",
    "type": "mcq"
  },
  {
    "question": "What is the primary purpose of constructing a precedence graph in the context of transaction scheduling?",
    "options": [
      "To detect deadlocks between transactions",
      "To ensure all transactions are recoverable",
      "To check for the absence of cycles to confirm conflict serializability",
      "To determine the optimal order of transaction execution"
    ],
    "answer": "To check for the absence of cycles to confirm conflict serializability",
    "type": "mcq"
  },
  {
    "question": "In the context of real-time database systems, why might an optimistic concurrency control protocol be preferred?",
    "options": [
      "It guarantees no transactions will miss their deadlines",
      "It minimizes the transaction rollback requirements",
      "It typically results in fewer missed deadlines compared to extended locking protocols",
      "It uses less memory than other protocols"
    ],
    "answer": "It typically results in fewer missed deadlines compared to extended locking protocols",
    "type": "mcq"
  },
  {
    "question": "Which of the following best describes the role of a wait-for graph in deadlock detection?",
    "options": [
      "It is used to track the sequence of operations performed by each transaction.",
      "It represents the dependencies among transactions waiting for resources.",
      "It is a visual tool for analyzing the performance of database queries.",
      "It schedules the transactions to ensure they are executed in a serial manner."
    ],
    "answer": "It represents the dependencies among transactions waiting for resources.",
    "type": "mcq"
  },
  {
    "question": "What is the primary disadvantage of using timeouts as a deadlock resolution strategy?",
    "options": [
      "It can lead to unnecessary transaction aborts if the timeout is too short.",
      "It increases the complexity of the database management system.",
      "It requires additional memory to track the timing of each transaction.",
      "It only works with databases that support snapshot isolation."
    ],
    "answer": "It can lead to unnecessary transaction aborts if the timeout is too short.",
    "type": "mcq"
  },
  {
    "question": "In the context of concurrency control, what anomaly might occur if two transactions concurrently modify the same data item without proper synchronization mechanisms?",
    "options": [
      "A deadlock due to cyclic resource dependencies.",
      "A lost update, where the changes made by one transaction are overwritten by another.",
      "Starvation, where a transaction indefinitely waits for resources.",
      "All transactions are rolled back due to system failure."
    ],
    "answer": "A lost update, where the changes made by one transaction are overwritten by another.",
    "type": "mcq"
  },
  {
    "question": "What is the primary purpose of using index-locking protocols in database transactions?",
    "options": [
      "To increase the speed of transaction processing",
      "To prevent the phantom phenomenon by locking index leaf nodes",
      "To reduce the storage space required for indices",
      "To eliminate the need for transaction logs"
    ],
    "answer": "To prevent the phantom phenomenon by locking index leaf nodes",
    "type": "mcq"
  },
  {
    "question": "In the context of index-locking, what must a transaction do before it can modify a tuple in a relation?",
    "options": [
      "Obtain exclusive locks on all tuples in the database",
      "Update the primary key of the relation",
      "Acquire exclusive locks on all index leaf nodes affected by the modification",
      "Release any shared locks it holds on the database"
    ],
    "answer": "Acquire exclusive locks on all index leaf nodes affected by the modification",
    "type": "mcq"
  },
  {
    "question": "How does the next-key locking technique help in preventing the phantom phenomenon?",
    "options": [
      "By locking the entire database during a transaction",
      "By locking only the tuples directly accessed by the transaction",
      "By locking the key value just greater than the last key value accessed in a range lookup",
      "By allowing unrestricted access to index leaf nodes"
    ],
    "answer": "By locking the key value just greater than the last key value accessed in a range lookup",
    "type": "mcq"
  },
  {
    "question": "Which type of lock allows multiple transactions to read but only one to write, ensuring no write operation occurs during multiple reads?",
    "options": ["Binary lock", "Exclusive lock", "Shared lock", "Certify lock"],
    "answer": "Shared lock",
    "type": "mcq"
  },
  {
    "question": "What is the primary difference between strict 2PL and rigorous 2PL in terms of lock release?",
    "options": [
      "Strict 2PL releases write locks after commit, while rigorous 2PL releases all locks after commit.",
      "Strict 2PL releases all locks before commit, while rigorous 2PL releases them after abort.",
      "Strict 2PL releases read locks after commit, while rigorous 2PL holds all locks until abort.",
      "Strict 2PL holds all locks until commit or abort, while rigorous 2PL releases them immediately after operation."
    ],
    "answer": "Strict 2PL releases write locks after commit, while rigorous 2PL releases all locks after commit.",
    "type": "mcq"
  },
  {
    "question": "In the context of locking protocols, what problem arises when each transaction in a set is waiting for an item locked by another transaction in the same set?",
    "options": [
      "Starvation",
      "Deadlock",
      "Lock thrashing",
      "Concurrency error"
    ],
    "answer": "Deadlock",
    "type": "mcq"
  },
  {
    "question": "Define the ACID property of 'atomicity' and explain how it ensures the integrity of database transactions.",
    "answer": "Atomicity ensures that all operations within a transaction are treated as a single unit, which either completely succeeds or completely fails. This property ensures the integrity of database transactions by preventing partial updates to the database, which can lead to data inconsistencies.",
    "type": "short-answer"
  },
  {
    "question": "Describe how the 'isolation' property of ACID affects the execution of concurrent transactions in a database system.",
    "answer": "The isolation property ensures that transactions executed concurrently appear to each other as if they are being executed in a serial order. This prevents transactions from interfering with each other, ensuring that each transaction's changes are invisible to other transactions until they are committed, thus maintaining data consistency.",
    "type": "short-answer"
  },
  {
    "question": "Evaluate the potential impact on system performance when enforcing strict isolation levels in transaction processing and suggest how systems might handle this.",
    "answer": "Strict isolation levels can significantly impact system performance due to the overhead of managing access controls and ensuring that transactions do not interfere with each other. Systems might handle this by implementing less stringent isolation levels, like Read Committed or Snapshot Isolation, which allow for better performance while still maintaining a reasonable level of data consistency.",
    "type": "short-answer"
  },
  {
    "question": "Explain the concept of serializability in database systems and why it is crucial for maintaining data consistency during concurrent transactions.",
    "answer": "Serializability in database systems refers to the property that a schedule of operations from concurrent transactions is equivalent to one that could have resulted from serial execution of those transactions. It is crucial for maintaining data consistency as it ensures that the execution of transactions concurrently will result in the same state as if they had been executed one after the other, thus preserving the correctness of the database despite concurrent access.",
    "type": "short-answer"
  },
  {
    "question": "Describe the difference between conflict serializability and view serializability, and provide an example scenario where one might be preferred over the other.",
    "answer": "Conflict serializability is a stricter form of serializability that requires the order of conflicting operations (like writes to the same data item) to be the same as in some serial execution. View serializability, on the other hand, only requires that each transaction must read the same values and produce the same output as it would in a serial execution, regardless of the order of conflicting operations. Conflict serializability is generally preferred for its ease of verification through precedence graphs, but view serializability might be used when the exact order of operations is less critical but the final state of the database must still be consistent.",
    "type": "short-answer"
  },
  {
    "question": "Evaluate the use of locking protocols versus timestamp ordering in managing concurrency in a database system, considering factors like system performance and the potential for deadlocks.",
    "answer": "Locking protocols manage concurrency by preventing other transactions from accessing data that a transaction is currently modifying, but they can lead to deadlocks where two transactions wait indefinitely for each other to release locks. Timestamp ordering avoids deadlocks by assigning a timestamp to each transaction and ensuring that transactions proceed in timestamp order, which can improve system performance by reducing wait times. However, timestamp ordering might lead to increased aborts if transactions are frequently out of order. The choice between the two depends on the specific requirements and characteristics of the database system, such as the expected transaction load and the importance of minimizing delays.",
    "type": "short-answer"
  },
  {
    "question": "Explain the difference between the wait-die and wound-wait schemes in managing deadlocks.",
    "answer": "In the wait-die scheme, an older transaction is allowed to wait if it requests a lock held by a younger transaction, but a younger transaction requesting a lock held by an older transaction will be aborted and restarted. In contrast, the wound-wait scheme allows a younger transaction to wait for an older transaction, but an older transaction will preempt and abort a younger transaction holding a requested lock. Both schemes aim to prevent deadlock by ensuring that transactions only wait for those that are either younger or older, respectively, thus avoiding cycles in the wait-for graph.",
    "type": "short-answer"
  },
  {
    "question": "Describe how the cautious waiting algorithm helps in preventing deadlocks and compare its effectiveness to the no waiting algorithm.",
    "answer": "The cautious waiting algorithm prevents deadlocks by allowing a transaction to wait only if the transaction holding the desired lock is not blocked by another transaction. If the lock holder is blocked, the requesting transaction is aborted to avoid potential deadlocks. This method ensures that no transaction waits for another that is already waiting, thus preventing cycles in the wait-for graph. Compared to the no waiting algorithm, where transactions are immediately aborted if they cannot obtain a lock, cautious waiting reduces unnecessary aborts and restarts by allowing some waiting, but only under safe conditions.",
    "type": "short-answer"
  },
  {
    "question": "Evaluate the practicality of using timeouts as a deadlock handling mechanism in a high-transaction database environment.",
    "answer": "Using timeouts as a deadlock handling mechanism involves aborting transactions that exceed a predefined waiting time, assuming they might be deadlocked. This method is simple and has low overhead, making it attractive for environments where quick resolution is needed. However, in high-transaction environments, it can lead to frequent unnecessary aborts, especially if the timeout is not optimally configured. Transactions might be aborted even if they are not actually deadlocked, potentially leading to increased overhead from repeated transaction restarts and reduced system throughput.",
    "type": "short-answer"
  },
  {
    "question": "Explain the phantom phenomenon in the context of database transactions and how it can affect data consistency.",
    "answer": "The phantom phenomenon occurs when a transaction reads a set of rows that satisfy a search condition, and a subsequent transaction inserts a new row that also satisfies the original search condition. This can lead to inconsistencies as the first transaction does not see the new row, potentially causing unexpected results in data consistency.",
    "type": "short-answer"
  }
]
